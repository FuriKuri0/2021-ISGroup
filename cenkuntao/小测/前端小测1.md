## 前端小测

### 1. 全局函数有哪些

setTimeout、setInterval、removeTimeout、removeInterval、

### 2. 继承的几种方式，有什么区别

1. 寄生式继承：通过一个函数来返回实例，避免实例化继承对象

2. 组合式继承：实现了方法的公有以及数据的私有。但存在需要两次创建那什么，这里存在效率问题

2. 寄生式组合继承：目前效率最高的继承方式，有寄生式的优点和组合式的优点

3. 共享式继承：属性方法共享

### 3. 创建对象的几种方式，谈谈理解

1. 通过new关键字，在创建其他类型对象的时候用得较多
2. 通过对象字面量，在创建object类型是比较方便，用得较多

### 4. new创建对象时做了些什么

1. 将实例对象的constructor指向该对象类型，该对象实例继承对象类型的原型属性

### 5. 闭包是什么，有什么作用和缺点

1. 闭包是在一个函数里面声明另一个函数
2. 作用：使用闭包，可以通过作用域链访问外部变量
3. 缺点：容易造成内存泄漏

### 6. this的指向有哪些

1. 在箭头函数中，this指向声明箭头函数时，箭头函数的包含对象
2. 在普通函数中，this指向使用普通函数时，普通函数的包含对象
3. 在全局作用域中声明的箭头函数，this指向window
4. 在使用apply和call创建函数是可以通过传参指定其this的指向
5. 在定时器中的箭头函数，this指向定时器本身

### 7. 类和构造函数的区别

1. 通过构造函数，可以实现属性数据的私有，就是直接再自己执行一遍函数，缺点是无法实现公用函数或者是代码的凝聚力差
2. 类：类可以实现方法的私有以及属性的私有，类的一部分是在构造函数的基础上发展而来的

### 8. apply、call、bind的区别？

1. apply和call的区别：apply传入的第二个参数是一个可迭代对象；而call是接受一个个的参数来构建函数（就相当于把可迭代对象拆散成一个个参数的样子）

### 9. 关于事件循环

说说以下代码执行结果，并给出解释：

```js
console.log(1);
setTimeout(function(){
    console.log(2);
},0)// 1. 定时器 得加入信息队列 异步

new Promise(function(resolve,reject){
    console.log(3)// 2. 这是同步的打印 先打印3
    resolve();// 3. 手动解决事件 在事件结果之后的代码不会执行
    setTimeout(function(){
        console.log(4);// 4. 所以4不打印
    },0);
}).then(res=>{
    // 5. 这个是异步打印 加入信息队列
    console.log(5);
})
// 6. 同步的打印 打印6 该线程的同步操作结束 进行异步代码信息处理
// 2排在5的前面 先打印2 再打印5
console.log(6);
```

1. 执行结果：3 6 2 5
2. 解释：见代码



### 10.一个随机整数组，将所有大于0的值相加。进阶：两句以内。

例：[-1, 3, 2, 0] => 5



### 11.原型和原型链是什么？显示原型和隐式原型的区别？原型链的作用？

1. 原型是定义在对象上的一个属性，这个属性由实例共享
2. 原型链：B对象的原型是A对象的实例，C对象的原型是B对象的实例，以此类推，构成一条原型链，原型链上方法共享
3. 显式原型：显式原型是上一级的原型
4. 隐式原型：隐式原型是是非上一级原型，比如说object是Array实例的原型，与显式原型的区别在于是否直接有联系
5. 原型链的作用：通过原型链，可以实现方法的共享

### 12.作用域链和执行上下文的区别是什么？他们分别的作用是什么？

1. 作用域链与执行上下文的区别：访问作用域链只能向上，执行上下文可以向上向下访问
2. 作用：通过作用域链，可以逐级向上访问变量函数

### 13.Function构造函数的显示原型和隐式原型是什么？两者有什么关系？

1. 显式原型是Function，隐式原型是Object
2. 关系：Function的原型是Object的实例