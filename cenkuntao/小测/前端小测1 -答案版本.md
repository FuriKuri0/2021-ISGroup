## 前端小测

### 1. 全局函数有哪些

setTimeout、setInterval、removeTimeout、removeInterval、

查找：decodeURI()、decodeURIComponent()、encodeURI()、encodeURIComponent()、escape()、eval()、isFinite()、Number()、isNaN()、parseFloat()、parseInt()、String()、unescape()

总结：这里是一个都没有对

### 2. 继承的几种方式，有什么区别

1. 寄生式继承：通过一个函数来返回实例，避免实例化继承对象
2. 组合式继承：实现了方法的公有以及数据的私有。但存在需要两次创建那什么，这里存在效率问题
3. 寄生式组合继承：目前效率最高的继承方式，有寄生式的优点和组合式的优点
3. 共享式继承：属性方法共享

查找：

1. 原型链：数据共享，容易造成混乱；创建子类时不能向超类性传递参数
2. 盗用构造函数：无法实现函数的复用；可以向超类型传递参数
3. 组合继承：组合原型式与盗用构造函数，有这两种方式的优点，但调用了两次超类的构造函数，导致子类中多了很多不必要的属性
4. 原型式继承：不是为了创建一个新的类型，知识对某个对象实现一种简单的继承，缺点与原型链一样
5. 寄生式继承：对一个简单的对象实现继承，可以对实例进行扩展，缺点与构造函数一样
6. 寄生组合式继承：使用超类型的原型为副本作为子类型的原型，避免创建不必要的属性，集中了寄生式与组合继承的优先

总结：对继承这一部分有模糊的了解，大致清楚实现方法与优缺点

### 3. 创建对象的几种方式，谈谈理解

1. 通过new关键字，在创建其他类型对象的时候用得较多
2. 通过对象字面量，在创建object类型是比较方便，用得较多

查找：

1. 工厂模式：用函数来封装创建对象的细节，在函数里面创建对象并返回对象。缺点：无法识别一个函数的类型
2. 构造函数模式：给构造函数传递不同的参数，调用构造函数来创建不同对象。优点：可以将实例标识为一种特定的类型；缺点：方法没有复用，造成冗余
3. 原型模式：通过原型链，让所有对象共享属性和方法，这是优点也是缺点
4. 组合使用欧冠构造函数和原型模式：构造函数定义实例私有的属性，原型模式定义方法和共享的属性

总结：这是一个在自己做的时候完全没有印象的问题，但在查找之后可以知道自己是对这个问题有所了解的

### 4. new创建对象时做了些什么

1. 将实例对象的constructor指向该对象类型，该对象实例继承对象类型的原型属性

查找：

1. 创建一个新对象
2. 将构造函数的作用域赋给新对象（因此this指向这个对象）
3. 执行构造函数中的代码（为这个新对象添加属性）
4. 返回新对象

总结：这也是一个自己做的时候完全没有印象的问题，明明做笔记的时候是有记下来的

### 5. 闭包是什么，有什么作用和缺点

1. 闭包是在一个函数里面声明另一个函数
2. 作用：使用闭包，可以通过作用域链访问外部变量
3. 缺点：容易造成内存泄漏

查找：

1. 闭包是指有权访问另一个函数作用域中的变量的函数
2. 优点：变量长期驻扎在内存中；避免全局变量的污染；私有成员的存在
3. 缺点：变量常驻内存会增大内存的使用量，使用不当会造成内存泄漏

总结：

1. 闭包的概念问题不大，但对闭包的使用很少，所以熟练度很低

### 6. this的指向有哪些

1. 在箭头函数中，this指向声明箭头函数时，箭头函数的包含对象
2. 在普通函数中，this指向使用普通函数时，普通函数的包含对象
3. 在全局作用域中声明的箭头函数，this指向window
4. 在使用apply和call创建函数是可以通过传参指定其this的指向
5. 在定时器中的箭头函数，this指向定时器本身

### 7. 类和构造函数的区别

1. 通过构造函数，可以实现属性数据的私有，就是直接再自己执行一遍函数，缺点是无法实现公用函数或者是代码的凝聚力差
2. 类：类可以实现方法的私有以及属性的私有，类的一部分是在构造函数的基础上发展而来的

查找：

1. 类的背后使用的仍然是原型和构造函数的概念
2. 区别：构造函数是类的基础；类可以有构造函数方法

### 8. apply、call、bind的区别？

1. apply和call的区别：apply传入的第二个参数是一个可迭代对象；而call是接受一个个的参数来构建函数（就相当于把可迭代对象拆散成一个个参数的样子）

补充：

1. bind语法和call一样，区别在于立刻执行还是等待执行，bind可以延迟调用，apply和call直接调用

### 9. 关于事件循环

说说以下代码执行结果，并给出解释：

```js
console.log(1);
setTimeout(function(){
    console.log(2);
},0)// 1. 定时器 得加入信息队列 异步

new Promise(function(resolve,reject){
    console.log(3)// 2. 这是同步的打印 先打印3
    resolve();// 3. 手动解决事件 在事件结果之后的代码不会执行
    setTimeout(function(){
        console.log(4);// 4. 所以4不打印
    },0);
}).then(res=>{
    // 5. 这个是异步打印 加入信息队列
    console.log(5);
})
// 6. 同步的打印 打印6 该线程的同步操作结束 进行异步代码信息处理
// 2排在5的前面 先打印2 再打印5
console.log(6);
```

1. 执行结果：1 3 6 2 5
2. 解释：见代码

问题：为什么5会打印在6前面，在2的前面

```js
console.log(1);

setTimeout(function() {
        console.log(2);
    }, 0) // 1. 定时器 得加入信息队列 异步

new Promise(function(resolve, reject) {
    console.log(3) // 2. 这是同步的打印 先打印3
    resolve(); // 3. 手动解决事件 在事件结果之后的代码不会执行
    setTimeout(function() {
        console.log(4); // 4. 在期约解决后并不会立刻跳入下一阶段 这里的定时器还是要执行的
    }, 0);
}).then(res => {
    // 5. 这个是同步打印？ 期约拒绝之后是异步执行
    // 但是期约解决之后还是同步执行？？
    // 如果是同步执行那5应该在6前面 这个是不一样的异步执行？
    console.log(5);
})

// 6. 同步的打印 打印6 该线程的同步操作结束 进行异步代码信息处理
// 2排在5的前面 先打印2 再打印5
console.log(6);
// 1 3 6 2 5

// 1
// 3
// 6
// 5 
// 2
// 4
```



### 10.一个随机整数组，将所有大于0的值相加。进阶：两句以内。

例：[-1, 3, 2, 0] => 5

```js
const arr = [-4, 0, 2, 0, 4, 0, -3, -9];
console.log(arr.filter((item, index, array) => item > 0).reduce((prev, cur, index, array) => prev + cur););// 6
```



### 11.原型和原型链是什么？显示原型和隐式原型的区别？原型链的作用？

1. 原型是定义在对象上的一个属性，这个属性由实例共享
2. 原型链：B对象的原型是A对象的实例，C对象的原型是B对象的实例，以此类推，构成一条原型链，原型链上方法共享
3. 显式原型：显式原型是上一级的原型
4. 隐式原型：隐式原型是是非上一级原型，比如说object是Array实例的原型，与显式原型的区别在于是否直接有联系
5. 原型链的作用：通过原型链，可以实现方法的共享

查找：

1. 所有引用类型都有一个_proto__（隐式原型）属性，属性值是一个普通对象
2. 所有函数都有一个prototype（原型）对象，属性值是一个普通的对象
3. 所有引用类型的隐式原型属性都指向它的构造函数的prototype
4. 原型链是查找对象的某个属性时，首先从对象本身属性上查找，找不到就去它的构造函数的原型上找，找不到就到构造函数的的构造函数的原型上找，这样一层层向上查找就会形成一个链式结构，即原型链
5. 显示原型与隐式原型的区别：我们可以操作显式原型，但不能操作隐式原型

### 12.作用域链和执行上下文的区别是什么？他们分别的作用是什么？

1. 作用域链与执行上下文的区别：访问作用域链只能向上，执行上下文可以向上向下访问
2. 作用：通过作用域链，可以逐级向上访问变量函数

查找：

1. 执行上下文是代码执行的环境（执行环境、变量对象、this、作用域链）
2. 区别：作用域链是执行上下文创建的一个变量对象的一个属性；执行上下文是抽象的，但作用域链是真是存在的，是一个保存着一个个变量对象的数组结构
3. 上下文的作用：执行上下文决定了该变量或函数可以访问哪些数据，以及它们的行为

### 13.Function构造函数的显示原型和隐式原型是什么？两者有什么关系？

1. 显式原型是Function，隐式原型是Object
2. 关系：Function的原型是Object的实例